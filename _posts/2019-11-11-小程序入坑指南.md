---
layout:     post
title:      小程序入坑指南
subtitle:   
date:       2018-10-27
author:     5只猫
header-img: img/article-bg.jpg
catalog: true
tags:
    - 微信小程序
---

# 小程序入坑指南

# 前言
最近要开始做毕设了，打算做的小程序，写此篇是为了不让下一次再遇到同样的问题的时候，还要百度。

## 后台无法获取请求的数据
后端代码(c#):
```
string content = Request["content"];
```
微信小程序端:
```
wx.request({
      url: config.host +'xxxxx',
      method:'POST',
      header: {
        'content-type': 'application/x-www-form-urlencoded' 
      },
      success:(res)=>{
      },
      fial:()=>
      },
      complete:()=>{
      }
    })
```
一定要加上这几句话，否则后台获取不到请求的参数。
```
 header: {
        'content-type': 'application/x-www-form-urlencoded' 
      }
 ```
 ## 微信小程序获取FormId
 要获得FormId，需要在标签中声明
 ```
 report-submit="true"
 ```
 .wxml 代码
 ```
 <form report-submit="true" bindsubmit="formSubmit" bindreset="formReset">
  <label>姓名</label>
  <input name="name" />
  <button formType="submit" type="primary">提交表单</button>
</form>
 ```
 .js 代码如下
 ```
 formSubmit: function (e) {
  // 获取表单id
  formId = e.detail.formId;
  // 非真机运行时 formId 应该为 the formId is a mock one
  console.log('表单id:', formId );
}
 ```
tips
* 在微信开发者工具中运行获取的 formId 为 the formId is a mock one ，要获得真实有效的 formId 需要在真机上运行。
* 生成的formid有效期是7天，并且只能用户给当前用户发送模板消息，所以往往是不够的，需要不断的获取formid存下来。

## Session验证登录
原理：
* 在服务器端有一个Session池，用来存放用户存放的session中的数据。
Session对于每一个客户端（或者说浏览器实例）是人手一分，用户首次与服务器建立连接的时候，服务器会给用户发送一个SessionID作为标识。浏览器会把这个sessionId包含在HTTP头部提交给web服务器，而这个sessionId是以cookie的形式保存在客户端的内存中。
* session中保存的数据是在服务端的，而每个用户进行登录的操作，都要进行Sessio写入，所以建议慎用Session。

~~~
[HttpPost]
public string TestSession()
{
    string useropenid = Request["useropenid"];
    Session["userOpenId"] = useropenid;
    Session.Timeout = 2; //设置过期时间
    return JsonConvert.SerializeObject(new
    {
        SessionID = Session.SessionID, //当前sessionid
    });
}
~~~
* 浏览器关闭以后，当前会话就结束了，存在内存中的sessionid就回收了。
~~~
string userOpenId=(string)Session["userOpenId"];
if (userOpenId == "") //当session为空时
{
    ReturnMessage returnMessage = new ReturnMessage()
    {
        Message = "Session过期/非法登录,请重新登录",
        Succeed = false,
    };
    filterContext.Result = Json(returnMessage);
    return;
}
~~~
当你在请求体中放了你的sessionid，在服务端只要通过Session["你设置的名字"]就可以取你设置的session值。
* 小程序不像浏览器，所以需要将sessionid存在本地，下一次请求时，将sessionid从本地取出来，放到http头部，来模拟一直开着浏览器的情况。
~~~

header: {
  'content-type': 'application/x-www-form-urlencoded',
  'cookie': 'ASP.NET_SessionId=' + sessionid
},
~~~

## 微信小程序登录
![当前用户权限](/img/postimages/QQ截图20181103140940.jpg)
先来一张官方的登录时序图，非常清楚直接。
1. 先在小程序调用wx.login()方法，在success回调里获取code。
![当前用户权限](/img/postimages/QQ截图20181103141447.jpg)
2. 在自己的服务器搭一个接口，小程序调用这个接口。正这个接口里，去请求微信提供的接口，来获取useropenid。[微信提供的获取useropenid的接口](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/code2Session.html)
3. 这个useropenid是微信提供的，每一个用户，在当前的这个小程序里，都是唯一的。所以到这一步，其实用户的主键已经出来了。微信不建议将这个useropenid传给用户，而是在自己的服务器上自定义登录状态。其实就是session。
4. 将session传给微信小程序，并放在存储中。
5. 小程序下一次发送请求的时候，将session带上就行。

## THANKS TO
* [小程序 表单 formId 为 the formId is a mock one](https://blog.csdn.net/lichenliang666/article/details/79346643)
* [微信小程序之保持登录状态即session不改变（Java）](https://www.cnblogs.com/gdutzyh/p/7251432.html)
#[微信小程序 官方api] (https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html)















